import torch.nn as nn
import torch.nn.functional as F


class OnlineTripletLoss(nn.Module):
    """
    Online Triplets loss. Takes a batch of image and text embeddings, where each image embedding has its corresponding
    text embedding. Depending on the mode (image or text), the triplets are generated using triplet_selector object.
    If we are doing Image-to-Text retrieval, the triplets are generated by using the image embedding as the anchor,
    the corresponding text embedding as the positive, and a negative text embedding (from a different image) as the
    negative (depending on the TripletSelector object, the negative text embedding can be the hardest negative, the
    semi-hard negative, or the random negative).
    If we are doing Text-to-Image retrieval, the triplets are generated by using the text embedding as the anchor, the
    corresponding image embedding as the positive, and a negative image embedding (from a different text) as the negative
    (depending on the TripletSelector object, the negative image embedding can be the hardest negative, the semi-hard
    negative, or the random negative).
    """

    def __init__(self, margin, triplet_selector):
        super(OnlineTripletLoss, self).__init__()
        self.margin = margin
        self.triplet_selector = triplet_selector

    def forward(self, img_embeddings, text_embeddings):
        # The embeddings are 4D tensors (batch_size, features, 1, 1)
        img_embeddings = img_embeddings.squeeze()
        text_embeddings = text_embeddings.squeeze()

        triplets = self.triplet_selector.get_triplets(img_embeddings, text_embeddings)

        if img_embeddings.is_cuda:
            triplets = triplets.cuda()

        # Calculate the Euclidean distances between the anchor-positive and anchor-negative pairs
        distance_positive = (img_embeddings[triplets[:, 0]] - text_embeddings[triplets[:, 1]]).pow(2).sum(1)
        distance_negative = (img_embeddings[triplets[:, 0]] - text_embeddings[triplets[:, 2]]).pow(2).sum(1)

        # Formula for triplets loss
        losses = F.relu(distance_positive - distance_negative + self.margin)

        return losses.mean()
